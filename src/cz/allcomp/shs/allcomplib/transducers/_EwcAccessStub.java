/**
 * Copyright (c) 2015, Václav Vilímek
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 	- Redistributions of source code must retain the above copyright notice, this list 
 * 	  of conditions and the following disclaimer.
 *  - Redistributions in binary form must reproduce the above copyright , this list 
 *    of conditions and the following disclaimer in the documentation and/or other materials 
 *    provided with the distribution.
 *  - Neither the name of the ALLCOMP a.s. nor the of its contributors may be used to endorse 
 *    or promote products from this software without specific prior written permission.
 *    
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL VÁCLAV VILÍMEK BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package cz.allcomp.shs.allcomplib.transducers;

import cz.allcomp.shs.allcomplib.common.ByteSeqHelper;
import cz.allcomp.shs.allcomplib.common.IntSeqHelper;
import cz.allcomp.shs.allcomplib.common.LongSeqHelper;
import cz.allcomp.shs.allcomplib.common.ShortSeqHelper;
import cz.allcomp.shs.allcomplib.notice.Notice;
import cz.allcomp.shs.allcomplib.notice.NoticeHelper;


/**
* transducers/_EwcAccessStub.java .
* Generated by the IDL-to-Java compiler (portable), version "3.2"
* from /home/petr/secret/ewa/AllNet.idl
* Sunday, 15 February 2015 11:26:13 o'clock CET
*/


/** 
  * The <code>EwcAccess</code> is the only interface to read (and write) data from the Ewc server.
  * <p> The Ewc address is specified by short (two bytes) value, while Ewc address is 255 maximum.
  * The higher byte is reserved to specify the Ewc net when more then one is present on single server.
  */
public class _EwcAccessStub extends org.omg.CORBA.portable.ObjectImpl implements EwcAccess
{


  /**
      * An EWC class signature getter.
      * <p> This signature identifies which class instance holds data of the given Ewc.
      * It is mainly determined by MSB of the hardware identification number.
      * <p> No ones are defined in this idl file since it's number may be growing.
      * But numbers may be converted to strings using method described
      * in {@link Signature} interface.
      * <p> For reading more info and/or more Ewc at once, see
      * {@link #getId(short firstEwc, short lastEwc, int idSet)} and
      * {@link #gtId(long selected, int idSet)} methods.
      * @param ewc the address of the Ewc of interest
      * @return an EWC class signature for a given EWC
      */
  public int gType (short ewc) throws EwcNonExist
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("gType", true);
                $out.write_short (ewc);
                $in = _invoke ($out);
                int $result = $in.read_long ();
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:transducers/EwcNonExist:1.0"))
                    throw EwcNonExistHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return gType (ewc        );
            } finally {
                _releaseReply ($in);
            }
  } // gType


  /**
      * Communication status flags.
      * ADDR_VALID, SW_VALID, HW_VALID, HALL_VALID, DATA_VALID, OUTS_VALID, BUS_OK and SYNC_OUT are 
      * positions defined. Rest are implementation dependant flags.
      * <p> For reading more info and/or more Ewc at once, see
      * {@link #getId(short firstEwc, short lastEwc, int idSet)} and
      * {@link #gtId(long selected, int idSet)} methods.
      * @see getS();
      * @param ewc the address of the Ewc of interest
      * @return a communication state signature for a given EWC
      */
  public int gS (short ewc) throws EwcNonExist
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("gS", true);
                $out.write_short (ewc);
                $in = _invoke ($out);
                int $result = $in.read_long ();
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:transducers/EwcNonExist:1.0"))
                    throw EwcNonExistHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return gS (ewc        );
            } finally {
                _releaseReply ($in);
            }
  } // gS


  /**
      * Ewc's hardware identification number getter.
      * <p> The MSB identifies function of this Ewc.
      * <p> The second significant byte identifies hardware issue of this Ewc.
      * <p> The two lower bytes holds a serial number.
      * <p> The best print format for this number is hexadecimal.
      * <p> For reading more info and/or more Ewc at once, see
      * {@link #getId(short firstEwc, short lastEwc, int idSet)} and
      * {@link #gtId(long selected, int idSet)} methods.
      * @param ewc the address of the Ewc of interest
      * @return a hardware identification number for a given EWC
      */
  public int gHw (short ewc) throws EwcNonExist
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("gHw", true);
                $out.write_short (ewc);
                $in = _invoke ($out);
                int $result = $in.read_long ();
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:transducers/EwcNonExist:1.0"))
                    throw EwcNonExistHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return gHw (ewc        );
            } finally {
                _releaseReply ($in);
            }
  } // gHw


  /**
      * Ewc's software version number getter.
      * <p> The MSB is the binary coded main version number.
      * <p> The lower three bytes holds fraction version number.
      * Every byte holds one ASCII (or Latin 1) fractional character.
      * It is typically a digit (0x30..0x39) but it may be a letter too.
      * If all the byte remains are zero, there are no more characters.
      * <p> For reading more info and/or more Ewc at once, see
      * {@link #getId(short firstEwc, short lastEwc, int idSet)} and
      * {@link #gtId(long selected, int idSet)} methods.
      * @param ewc the address of the Ewc of interest
      * @return a software version number for a given EWC
      */
  public int gSw (short ewc) throws EwcNonExist
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("gSw", true);
                $out.write_short (ewc);
                $in = _invoke ($out);
                int $result = $in.read_long ();
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:transducers/EwcNonExist:1.0"))
                    throw EwcNonExistHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return gSw (ewc        );
            } finally {
                _releaseReply ($in);
            }
  } // gSw


  /**
      * Info about how old are this data.
      * <p> If there is no new data from the Ewc for some time
      * (for example due to communication errors), the older data remains valid.
      * This value distinguishes between the fresh data with no change
      * and the old data. Of course (if communication error remains)
      * after some time the Ewc becomes offline.
      * <p> For reading more info and/or more Ewc at once, see
      * {@link #getId(short firstEwc, short lastEwc, int idSet)} and
      * {@link #gtId(long selected, int idSet)} methods.
      * @param ewc the address of the Ewc of interest
      * @return a time in millis from the last message was received by a given EWC
      * @see	#gState(short ewc)
      */
  public int gTime (short ewc) throws EwcNonExist
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("gTime", true);
                $out.write_short (ewc);
                $in = _invoke ($out);
                int $result = $in.read_long ();
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:transducers/EwcNonExist:1.0"))
                    throw EwcNonExistHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return gTime (ewc        );
            } finally {
                _releaseReply ($in);
            }
  } // gTime


  /**
      * Bit field with up to 32 first digital inputs.
      * <p>If the Ewc has less then 32 digital inputs,
      * the bits not used for digital inputs may hold another information,
      * for example the first analog input. But this is implementation dependant.
      * <p> For reading more info and/or more Ewc at once, see
      * {@link #getId(short firstEwc, short lastEwc, int idSet)} and
      * {@link #gtId(long selected, int idSet)} methods.
      * @param ewc the address of the Ewc of interest
      * @return record 1 from the file 0x10 TTPA of given EWC
      */
  public int gHall (short ewc) throws EwcNonExist
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("gHall", true);
                $out.write_short (ewc);
                $in = _invoke ($out);
                int $result = $in.read_long ();
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:transducers/EwcNonExist:1.0"))
                    throw EwcNonExistHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return gHall (ewc        );
            } finally {
                _releaseReply ($in);
            }
  } // gHall


  /**
      * @param firstEwc the first Ewc address to read from
      * @param lastEwc the last Ewc address to read from
      * @return number of digital inputs for EWCs first..last
      */
  public short[] getInLen (short firstEwc, short lastEwc) throws EwcNonExist
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getInLen", true);
                $out.write_short (firstEwc);
                $out.write_short (lastEwc);
                $in = _invoke ($out);
                short $result[] = ShortSeqHelper.read ($in);
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:transducers/EwcNonExist:1.0"))
                    throw EwcNonExistHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return getInLen (firstEwc, lastEwc        );
            } finally {
                _releaseReply ($in);
            }
  } // getInLen


  /**
      * @param selected bit field indicating which Ewcs are to be read
      *	from bit 0 standing for Ewc address 1 to bit 63 standing for Ewc address 64
      * @return number of digital inputs for EWCs selected by bit field
      */
  public short[] gtInLen (long selected)
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("gtInLen", true);
                $out.write_longlong (selected);
                $in = _invoke ($out);
                short $result[] = ShortSeqHelper.read ($in);
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return gtInLen (selected        );
            } finally {
                _releaseReply ($in);
            }
  } // gtInLen


  /**
      * Digital input getter.
      * <p> It uses a positive logic,
      * i.e. active state of external signal gets <code>true</code>.
      * <p> It is up to the user to use index in range.
      * Otherwise a nonsense value is returned.
      * @param ewc the address of the Ewc of interest
      * @param i the input index from the interval 0..posInLenght-1
      * @return <code>true</code> if digital input is active
      */
  public boolean getIn (short ewc, short i) throws EwcNonExist
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getIn", true);
                $out.write_short (ewc);
                $out.write_short (i);
                $in = _invoke ($out);
                boolean $result = $in.read_boolean ();
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:transducers/EwcNonExist:1.0"))
                    throw EwcNonExistHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return getIn (ewc, i        );
            } finally {
                _releaseReply ($in);
            }
  } // getIn


  /**
      * Read backs output state as is read from the Ewc.
      * @param ewc the address of the Ewc of interest
      * @param i the output index
      * @return <code>true</code> if output is active (isn't switched off)
      */
  public boolean getBack (short ewc, short i) throws EwcNonExist
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getBack", true);
                $out.write_short (ewc);
                $out.write_short (i);
                $in = _invoke ($out);
                boolean $result = $in.read_boolean ();
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:transducers/EwcNonExist:1.0"))
                    throw EwcNonExistHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return getBack (ewc, i        );
            } finally {
                _releaseReply ($in);
            }
  } // getBack


  /**
      * @param firstEwc the first Ewc address to read from
      * @param lastEwc the last Ewc address to read from
      * @return an array of analogOut.length (number of analog (PWM) outputs)
      *	for EWCs first..last
      */
  public short[] getAOutLen (short firstEwc, short lastEwc) throws EwcNonExist
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getAOutLen", true);
                $out.write_short (firstEwc);
                $out.write_short (lastEwc);
                $in = _invoke ($out);
                short $result[] = ShortSeqHelper.read ($in);
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:transducers/EwcNonExist:1.0"))
                    throw EwcNonExistHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return getAOutLen (firstEwc, lastEwc        );
            } finally {
                _releaseReply ($in);
            }
  } // getAOutLen


  /**
      * @param selected bit field indicating which Ewcs are to be read from
      *	from bit 0 standing for Ewc address 1 to bit 63 standing for Ewc address 64
      * @return an array of analogOut.length (number of analog (PWM) outputs)
      *	for EWCs selected by bit field
      */
  public short[] gtAOutLen (long selected)
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("gtAOutLen", true);
                $out.write_longlong (selected);
                $in = _invoke ($out);
                short $result[] = ShortSeqHelper.read ($in);
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return gtAOutLen (selected        );
            } finally {
                _releaseReply ($in);
            }
  } // gtAOutLen


  /**
      * Sets single analogOut (analog (PWM) output).
      * <p> Possible value range is implementation dependant,
      * typically it is value from an interval 0..100 or 0..1000
      * @param ewc the address of the Ewc of interest
      * @param index the output index
      * @param value the new value for this output
      */
  public void sAOut (short ewc, short index, short value) throws EwcNonExist
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("sAOut", true);
                $out.write_short (ewc);
                $out.write_short (index);
                $out.write_short (value);
                $in = _invoke ($out);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:transducers/EwcNonExist:1.0"))
                    throw EwcNonExistHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                sAOut (ewc, index, value        );
            } finally {
                _releaseReply ($in);
            }
  } // sAOut


  /**
      * Sets multiple analogOut (analog (PWM) outputs) in a row.
      * <p> Outputs are set from the <code>first</code> up to the
      * <code>first + values.length - 1</code>
      * <p> Possible value range is implementation dependant,
      * typically it is value from an interval 0..100 or 0..1000
      * @param ewc the address of the Ewc of interest
      * @param first the index to the first output set
      * @param values the new values for these outputs
      */
  public void setAOut (short ewc, short first, short[] values) throws EwcNonExist
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("setAOut", true);
                $out.write_short (ewc);
                $out.write_short (first);
                ShortSeqHelper.write ($out, values);
                $in = _invoke ($out);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:transducers/EwcNonExist:1.0"))
                    throw EwcNonExistHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                setAOut (ewc, first, values        );
            } finally {
                _releaseReply ($in);
            }
  } // setAOut


  /**
      * Sets multiple analogOut (analog (PWM) outputs) selected by bit field.
      * <p> Possible value range is implementation dependant,
      * typically it is value from an interval 0..100 or 0..1000
      * @param ewc the address of the Ewc of interest
      * @param selected bit field indicating which outputs to be set
      *	from bit0 standing for index 0 to bit 63 standing for index 63
      * @param values the new values for the outputs selected
      */
  public void stAOut (short ewc, int selected, short[] values) throws EwcNonExist
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("stAOut", true);
                $out.write_short (ewc);
                $out.write_long (selected);
                ShortSeqHelper.write ($out, values);
                $in = _invoke ($out);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:transducers/EwcNonExist:1.0"))
                    throw EwcNonExistHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                stAOut (ewc, selected, values        );
            } finally {
                _releaseReply ($in);
            }
  } // stAOut


  /**
      * Read back a single analog output value as it was set last time.
      * @param ewc the address of the Ewc of interest
      * @param index the analog (PWM) output index
      * @return the value last set
      */
  public short gAOut (short ewc, short index) throws EwcNonExist
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("gAOut", true);
                $out.write_short (ewc);
                $out.write_short (index);
                $in = _invoke ($out);
                short $result = $in.read_short ();
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:transducers/EwcNonExist:1.0"))
                    throw EwcNonExistHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return gAOut (ewc, index        );
            } finally {
                _releaseReply ($in);
            }
  } // gAOut


  /**
      * Read back a multiple analog output values as they were set last time.
      * @param ewc the address of the Ewc of interest
      * @param first the index to the first output value to read
      * @param cnt number of outputs to read
      * @return an array of values last set
      */
  public short[] getAOut (short ewc, short first, byte cnt) throws EwcNonExist
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getAOut", true);
                $out.write_short (ewc);
                $out.write_short (first);
                $out.write_octet (cnt);
                $in = _invoke ($out);
                short $result[] = ShortSeqHelper.read ($in);
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:transducers/EwcNonExist:1.0"))
                    throw EwcNonExistHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return getAOut (ewc, first, cnt        );
            } finally {
                _releaseReply ($in);
            }
  } // getAOut


  /**
      * @param firstEwc the first Ewc address to read from
      * @param lastEwc the last Ewc address to read from
      * @return an array of switchOut.length (number of switching outputs)
      *	for EWCs first..last
      */
  public short[] getOutLen (short firstEwc, short lastEwc) throws EwcNonExist
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getOutLen", true);
                $out.write_short (firstEwc);
                $out.write_short (lastEwc);
                $in = _invoke ($out);
                short $result[] = ShortSeqHelper.read ($in);
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:transducers/EwcNonExist:1.0"))
                    throw EwcNonExistHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return getOutLen (firstEwc, lastEwc        );
            } finally {
                _releaseReply ($in);
            }
  } // getOutLen


  /**
      * @param selected bit field indicating which Ewcs are to be read from
      *	from bit 0 standing for Ewc address 1 to bit 63 standing for Ewc address 64
      * @return an array of switchOut.length (number of switching outputs)
      *	for EWCs selected by bit field
      */
  public short[] gtOutLen (long selected)
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("gtOutLen", true);
                $out.write_longlong (selected);
                $in = _invoke ($out);
                short $result[] = ShortSeqHelper.read ($in);
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return gtOutLen (selected        );
            } finally {
                _releaseReply ($in);
            }
  } // gtOutLen


  /**
      * Sets single switchOut (switching output).
      * <p> Possible value range is implementation dependant,
      * typically it is 0 for switch off and 1 for switch on.
      * A selector switches are using more values.
      * @param ewc the address of the Ewc of interest
      * @param index the output index
      * @param value the new value for this output
      */
  public void sOut (short ewc, short index, byte value) throws EwcNonExist
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("sOut", true);
                $out.write_short (ewc);
                $out.write_short (index);
                $out.write_octet (value);
                $in = _invoke ($out);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:transducers/EwcNonExist:1.0"))
                    throw EwcNonExistHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                sOut (ewc, index, value        );
            } finally {
                _releaseReply ($in);
            }
  } // sOut


  /**
      * sets switchOut (switching outputs) from first
      * Sets multiple switchOut (switching outputs) in a row.
      * <p> Outputs are set from the <code>first</code> up to the
      * <code>first + values.length - 1</code>
      * <p> Possible value range is implementation dependant,
      * typically it is 0 for switch off and 1 for switch on.
      * A selector switches are using more values.
      * @param ewc the address of the Ewc of interest
      * @param first the index to the first output set
      * @param values the new values for these outputs
      */
  public void setOut (short ewc, short first, byte[] values) throws EwcNonExist
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("setOut", true);
                $out.write_short (ewc);
                $out.write_short (first);
                ByteSeqHelper.write ($out, values);
                $in = _invoke ($out);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:transducers/EwcNonExist:1.0"))
                    throw EwcNonExistHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                setOut (ewc, first, values        );
            } finally {
                _releaseReply ($in);
            }
  } // setOut


  /**
      * Sets multiple switchOut (switching outputs) selected by bit field.
      * <p> Possible value range is implementation dependant,
      * typically it is 0 for switch off and 1 for switch on.
      * A selector switches are using more values.
      * @param ewc the address of the Ewc of interest
      * @param selected bit field indicating which outputs to be set
      *	from bit0 standing for index 0 to bit 63 standing for index 63
      * @param values the new values for the outputs selected
      */
  public void stOut (short ewc, int selected, byte[] values) throws EwcNonExist
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("stOut", true);
                $out.write_short (ewc);
                $out.write_long (selected);
                ByteSeqHelper.write ($out, values);
                $in = _invoke ($out);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:transducers/EwcNonExist:1.0"))
                    throw EwcNonExistHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                stOut (ewc, selected, values        );
            } finally {
                _releaseReply ($in);
            }
  } // stOut


  /**
      * Read back a single switching output value as it was set last time.
      * @param ewc the address of the Ewc of interest
      * @param index the switching output index
      * @return the value last set
      */
  public byte gOut (short ewc, short index) throws EwcNonExist
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("gOut", true);
                $out.write_short (ewc);
                $out.write_short (index);
                $in = _invoke ($out);
                byte $result = $in.read_octet ();
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:transducers/EwcNonExist:1.0"))
                    throw EwcNonExistHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return gOut (ewc, index        );
            } finally {
                _releaseReply ($in);
            }
  } // gOut


  /**
      * Read back a multiple switching output values as they were set last time.
      * @param ewc the address of the Ewc of interest
      * @param first the index to the first output value to read
      * @param cnt number of outputs to read
      * @return an array of values last set
      */
  public byte[] getOut (short ewc, short first, byte cnt) throws EwcNonExist
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getOut", true);
                $out.write_short (ewc);
                $out.write_short (first);
                $out.write_octet (cnt);
                $in = _invoke ($out);
                byte $result[] = ByteSeqHelper.read ($in);
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:transducers/EwcNonExist:1.0"))
                    throw EwcNonExistHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return getOut (ewc, first, cnt        );
            } finally {
                _releaseReply ($in);
            }
  } // getOut


  /**
      * @param firstEwc the first Ewc address to read from
      * @param lastEwc the last Ewc address to read from
      * @return an array of analogIn.length (number of voltages or counters)
      *	for EWCs first..last
      */
  public short[] getAInLen (short firstEwc, short lastEwc) throws EwcNonExist
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getAInLen", true);
                $out.write_short (firstEwc);
                $out.write_short (lastEwc);
                $in = _invoke ($out);
                short $result[] = ShortSeqHelper.read ($in);
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:transducers/EwcNonExist:1.0"))
                    throw EwcNonExistHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return getAInLen (firstEwc, lastEwc        );
            } finally {
                _releaseReply ($in);
            }
  } // getAInLen


  /**
      * @param selected bit field indicating which Ewcs are to be read from
      *	from bit0 standing for Ewc address 1 to bit 63 standing for Ewc address 64
      * @return an array of analogIn.length (number of voltages or counters)
      *	for EWCs selected by bit field
      */
  public short[] gtAInLen (long selected)
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("gtAInLen", true);
                $out.write_longlong (selected);
                $in = _invoke ($out);
                short $result[] = ShortSeqHelper.read ($in);
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return gtAInLen (selected        );
            } finally {
                _releaseReply ($in);
            }
  } // gtAInLen


  /**
      * Read an analog input value.
      * <p> Typically a result from A/D converter, normalised so
      * the most significant bit of A/D result is also MSB of this value.
      * <p> The drink machines (ECC and so) use this to transfer 16-bit dose counters.
      * <p> Some device (COMM itself) transfers temperatures
      * in centigrades as signed value here.
      * @param ewc the address of the Ewc of interest
      * @param index the analog input index
      * @return analogIn value (voltage or counter) for a given EWC
      */
  public short gAIn (short ewc, short index) throws EwcNonExist
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("gAIn", true);
                $out.write_short (ewc);
                $out.write_short (index);
                $in = _invoke ($out);
                short $result = $in.read_short ();
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:transducers/EwcNonExist:1.0"))
                    throw EwcNonExistHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return gAIn (ewc, index        );
            } finally {
                _releaseReply ($in);
            }
  } // gAIn


  /**
      * Read a multiple analog input values.
      * <p> Typically a result from A/D converter, normalised so
      * the most significant bit of A/D result is also MSB of this value.
      * <p> The drink machines (ECC and so) use this to transfer 16-bit dose counters.
      * <p> Some device (COMM itself) transfers temperatures
      * in centigrades as signed value here.
      * @param firstEwc the first Ewc address to read from
      * @param lastEwc the last Ewc address to read from
      * @param first the index to the first input value to read 
      * @param cnt number of inputs to read from every Ewc
      * @return an array of analogIn values (voltages or counters)
      *	for EWCs firstEwc..lastEwc
      */
  public short[] getAIn (short firstEwc, short lastEwc, short first, byte cnt) throws EwcNonExist
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getAIn", true);
                $out.write_short (firstEwc);
                $out.write_short (lastEwc);
                $out.write_short (first);
                $out.write_octet (cnt);
                $in = _invoke ($out);
                short $result[] = ShortSeqHelper.read ($in);
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:transducers/EwcNonExist:1.0"))
                    throw EwcNonExistHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return getAIn (firstEwc, lastEwc, first, cnt        );
            } finally {
                _releaseReply ($in);
            }
  } // getAIn


  /**
      * Read a multiple analog input values.
      * <p> Typically a result from A/D converter, normalised so
      * the most significant bit of A/D result is also MSB of this value.
      * <p> The drink machines (ECC and so) use this to transfer 16-bit dose counters.
      * <p> Some device (COMM itself) transfers temperatures
      * in centigrades as signed value here.
      * @param selected bit field indicating which Ewcs are to be read from
      *	from bit0 standing for Ewc address 1 to bit 63 standing for Ewc address 64
      * @param first the index to the first input value to read 
      * @param cnt number of inputs to read from every Ewc
      * @return an array of analogIn values (voltages or counters)
      *	for EWCs selected by bit field
      */
  public short[] gtAIn (long selected, short first, byte cnt) throws EwcNonExist
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("gtAIn", true);
                $out.write_longlong (selected);
                $out.write_short (first);
                $out.write_octet (cnt);
                $in = _invoke ($out);
                short $result[] = ShortSeqHelper.read ($in);
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:transducers/EwcNonExist:1.0"))
                    throw EwcNonExistHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return gtAIn (selected, first, cnt        );
            } finally {
                _releaseReply ($in);
            }
  } // gtAIn


  /**
      * @param firstEwc the first Ewc address to read from
      * @param lastEwc the last Ewc address to read from
      * @return an array of timerIn.length (number of temperatures or counters)
      *	for EWCs first..last
      */
  public short[] getTInLen (short firstEwc, short lastEwc) throws EwcNonExist
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getTInLen", true);
                $out.write_short (firstEwc);
                $out.write_short (lastEwc);
                $in = _invoke ($out);
                short $result[] = ShortSeqHelper.read ($in);
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:transducers/EwcNonExist:1.0"))
                    throw EwcNonExistHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return getTInLen (firstEwc, lastEwc        );
            } finally {
                _releaseReply ($in);
            }
  } // getTInLen


  /**
      * @param selected bit field indicating which Ewcs are to be read from
      *	from bit0 standing for Ewc address 1 to bit 63 standing for Ewc address 64
      * @return an array of timerIn.length (number of temperatures or counters)
      *	for EWCs selected by bit field
      */
  public short[] gtTInLen (long selected)
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("gtTInLen", true);
                $out.write_longlong (selected);
                $in = _invoke ($out);
                short $result[] = ShortSeqHelper.read ($in);
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return gtTInLen (selected        );
            } finally {
                _releaseReply ($in);
            }
  } // gtTInLen


  /**
      * Read a timer or other integer input value.
      * <p> Originally used for SMT160 temperature sensors data, measured by timers.
      * Temperature data are transferred in cents of Kelvin (thus it is unsigned value).
      * <p> Later also the 32 bit counters became transferred here.
      * @param ewc the address of the Ewc of interest
      * @param index the timerIn input index
      * @return timerIn value (temperature or counter) for a given EWC
      */
  public int gTIn (short ewc, short index) throws EwcNonExist
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("gTIn", true);
                $out.write_short (ewc);
                $out.write_short (index);
                $in = _invoke ($out);
                int $result = $in.read_long ();
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:transducers/EwcNonExist:1.0"))
                    throw EwcNonExistHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return gTIn (ewc, index        );
            } finally {
                _releaseReply ($in);
            }
  } // gTIn


  /**
      * Read a multiple timer or other integer input values.
      * <p> Originally used for SMT160 temperature sensors data, measured by timers.
      * Temperature data are transferred in cents of Kelvin (thus it is unsigned value).
      * <p> Later also the 32 bit counters became transferred here.
      * @param firstEwc the first Ewc address to read from
      * @param lastEwc the last Ewc address to read from
      * @param first the index to the first input value to read 
      * @param cnt number of input values to read from every Ewc
      * @return an array of timerIn values (temperatures or counters)
      *	from EWCs firstEwc..lastEwc
      */
  public int[] getTIn (short firstEwc, short lastEwc, short first, byte cnt) throws EwcNonExist
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getTIn", true);
                $out.write_short (firstEwc);
                $out.write_short (lastEwc);
                $out.write_short (first);
                $out.write_octet (cnt);
                $in = _invoke ($out);
                int $result[] = IntSeqHelper.read ($in);
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:transducers/EwcNonExist:1.0"))
                    throw EwcNonExistHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return getTIn (firstEwc, lastEwc, first, cnt        );
            } finally {
                _releaseReply ($in);
            }
  } // getTIn


  /**
      * Read a multiple timer or other integer input values.
      * <p> Originally used for SMT160 temperature sensors data, measured by timers.
      * Temperature data are transferred in cents of Kelvin (thus it is an unsigned value).
      * <p> Later also the 32 bit counters became transferred here.
      * @param selected bit field indicating which Ewcs are to be read from
      *	from bit0 standing for Ewc address 1 to bit 63 standing for Ewc address 64
      * @param first the index to the first input value to read 
      * @param cnt number of input values to read from every Ewc
      * @return an array of timerIn values (temperatures or counters)
      *	from EWCs selected by bit field
      */
  public int[] gtTIn (long selected, short first, byte cnt) throws EwcNonExist
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("gtTIn", true);
                $out.write_longlong (selected);
                $out.write_short (first);
                $out.write_octet (cnt);
                $in = _invoke ($out);
                int $result[] = IntSeqHelper.read ($in);
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:transducers/EwcNonExist:1.0"))
                    throw EwcNonExistHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return gtTIn (selected, first, cnt        );
            } finally {
                _releaseReply ($in);
            }
  } // gtTIn


  /**
      * @param firstEwc the first Ewc address to read from
      * @param lastEwc the last Ewc address to read from
      * @return an array of longIn.length (number of RFID items)
      *	for EWCs first..last
      */
  public short[] getLInLen (short firstEwc, short lastEwc) throws EwcNonExist
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getLInLen", true);
                $out.write_short (firstEwc);
                $out.write_short (lastEwc);
                $in = _invoke ($out);
                short $result[] = ShortSeqHelper.read ($in);
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:transducers/EwcNonExist:1.0"))
                    throw EwcNonExistHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return getLInLen (firstEwc, lastEwc        );
            } finally {
                _releaseReply ($in);
            }
  } // getLInLen


  /**
      * @param selected bit field indicating which Ewcs are to be read from
      *	from bit0 standing for Ewc address 1 to bit 63 standing for Ewc address 64
      * @return an array of longIn.length (number of RFID items)
      *	for EWCs selected by bit field
      */
  public short[] gtLInLen (long selected)
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("gtLInLen", true);
                $out.write_longlong (selected);
                $in = _invoke ($out);
                short $result[] = ShortSeqHelper.read ($in);
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return gtLInLen (selected        );
            } finally {
                _releaseReply ($in);
            }
  } // gtLInLen


  /**
      * Read a 64-bits long value.
      * <p> A RFID reader uses this only at time of writing.
      * @param ewc the address of the Ewc of interest
      * @param index the longIn input value index
      * @return longIn 64bit value (RFID) for a given EWC
      */
  public long gLIn (short ewc, short index) throws EwcNonExist
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("gLIn", true);
                $out.write_short (ewc);
                $out.write_short (index);
                $in = _invoke ($out);
                long $result = $in.read_longlong ();
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:transducers/EwcNonExist:1.0"))
                    throw EwcNonExistHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return gLIn (ewc, index        );
            } finally {
                _releaseReply ($in);
            }
  } // gLIn


  /**
      * Read a multiple 64-bits long values.
      * <p> A RFID reader uses this only at time of writing.
      * @param firstEwc the first Ewc address to read from
      * @param lastEwc the last Ewc address to read from
      * @param first the index to the first input value to read 
      * @param cnt number of input values to read from every Ewc
      * @return an array of longIn 64bit values (RFID)
      *	from EWCs firstEwc..lastEwc
      */
  public long[] getLIn (short firstEwc, short lastEwc, short first, byte cnt) throws EwcNonExist
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getLIn", true);
                $out.write_short (firstEwc);
                $out.write_short (lastEwc);
                $out.write_short (first);
                $out.write_octet (cnt);
                $in = _invoke ($out);
                long $result[] = LongSeqHelper.read ($in);
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:transducers/EwcNonExist:1.0"))
                    throw EwcNonExistHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return getLIn (firstEwc, lastEwc, first, cnt        );
            } finally {
                _releaseReply ($in);
            }
  } // getLIn


  /**
      * Read a multiple 64-bits long values.
      * <p> A RFID reader uses this only at time of writing.
      * @param selected bit field indicating which Ewcs are to be read from
      *	from bit0 standing for Ewc address 1 to bit 63 standing for Ewc address 64
      * @param first the index to the first input value to read 
      * @param cnt number of input values to read from every Ewc
      * @return an array of longIn 64bit values (RFID)
      *	from EWCs selected by bit field
      */
  public long[] gtLIn (long selected, short first, byte cnt) throws EwcNonExist
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("gtLIn", true);
                $out.write_longlong (selected);
                $out.write_short (first);
                $out.write_octet (cnt);
                $in = _invoke ($out);
                long $result[] = LongSeqHelper.read ($in);
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:transducers/EwcNonExist:1.0"))
                    throw EwcNonExistHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return gtLIn (selected, first, cnt        );
            } finally {
                _releaseReply ($in);
            }
  } // gtLIn


  /**
      * @param firstEwc the first Ewc address to read from
      * @param lastEwc the last Ewc address to read from
      * @return an array of StatisticInt.length (number of integer series statistic objects)
      *	for EWCs first..last
      */
  public short[] getStLen (short firstEwc, short lastEwc) throws EwcNonExist
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getStLen", true);
                $out.write_short (firstEwc);
                $out.write_short (lastEwc);
                $in = _invoke ($out);
                short $result[] = ShortSeqHelper.read ($in);
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:transducers/EwcNonExist:1.0"))
                    throw EwcNonExistHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return getStLen (firstEwc, lastEwc        );
            } finally {
                _releaseReply ($in);
            }
  } // getStLen


  /**
      * @param selected bit field indicating which Ewcs are to be read from
      *	from bit0 standing for Ewc address 1 to bit 63 standing for Ewc address 64
      * @return an array of StatisticInt.length (number of integer series statistic objects)
      *	for EWCs selected by bit field
      */
  public short[] gtStLen (long selected)
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("gtStLen", true);
                $out.write_longlong (selected);
                $in = _invoke ($out);
                short $result[] = ShortSeqHelper.read ($in);
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return gtStLen (selected        );
            } finally {
                _releaseReply ($in);
            }
  } // gtStLen


  /**
      * Get a statistical data from the last {@link #gNSt(short ewc, short index)} invocation.
      * <p> A statistic is calculated from the A/D conversion values
      * used for bucket conveyor load sensor on EWCS.
      * @param ewc the address of the Ewc of interest
      * @param index the statisticInt object index
      * @return statistical data from given EWC
      */
  public StInt gSt (short ewc, short index) throws EwcNonExist
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("gSt", true);
                $out.write_short (ewc);
                $out.write_short (index);
                $in = _invoke ($out);
                StInt $result = StIntHelper.read ($in);
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:transducers/EwcNonExist:1.0"))
                    throw EwcNonExistHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return gSt (ewc, index        );
            } finally {
                _releaseReply ($in);
            }
  } // gSt


  /**
      * Get a statistical data from the last {@link #gNSt(short ewc, short index)} invocation.
      * <p> A statistic is calculated from the A/D conversion values used for
      * bucket conveyor load sensor on EWCS.
      * @param firstEwc the first Ewc address to read from
      * @param lastEwc the last Ewc address to read from
      * @param first the index to the first statistics to read 
      * @param cnt number of statistics to read from every Ewc
      * @return array of statistical data objects from EWCs first..last
      */
  public StInt[] getSt (short firstEwc, short lastEwc, short first, byte cnt) throws EwcNonExist
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getSt", true);
                $out.write_short (firstEwc);
                $out.write_short (lastEwc);
                $out.write_short (first);
                $out.write_octet (cnt);
                $in = _invoke ($out);
                StInt $result[] = StIntSeqHelper.read ($in);
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:transducers/EwcNonExist:1.0"))
                    throw EwcNonExistHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return getSt (firstEwc, lastEwc, first, cnt        );
            } finally {
                _releaseReply ($in);
            }
  } // getSt


  /**
      * Get statistical data from the last invocation of this method.
      * <p> A statistic is calculated from the A/D conversion value 0 used for
      * bucket conveyor load sensor on EWCS.
      * <p> To read data not clearing series use {@link #gSt(short ewc, short index)}.
      * @param ewc the address of the Ewc of interest
      * @param index the statisticInt object index
      * @return statistical data from given EWC
      */
  public StInt gNSt (short ewc, short index) throws EwcNonExist
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("gNSt", true);
                $out.write_short (ewc);
                $out.write_short (index);
                $in = _invoke ($out);
                StInt $result = StIntHelper.read ($in);
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:transducers/EwcNonExist:1.0"))
                    throw EwcNonExistHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return gNSt (ewc, index        );
            } finally {
                _releaseReply ($in);
            }
  } // gNSt


  /**
      * Get statistical data from the last invocation of this method.
      * <p> A statistic is calculated from the A/D conversion value 0 used for
      * bucket conveyor load sensor on EWCS.
      * <p> To read data not clearing series use {@link #getSt(short firstEwc, short lastEwc, short first, byte cnt)}.
      * @param firstEwc the first Ewc address to read from
      * @param lastEwc the last Ewc address to read from
      * @param first the index to the first statistics to read 
      * @param cnt number of statistics to read from every Ewc
      * @return array of statistical data objects from EWCs first..last
      */
  public StInt[] getNSt (short firstEwc, short lastEwc, short first, byte cnt) throws EwcNonExist
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getNSt", true);
                $out.write_short (firstEwc);
                $out.write_short (lastEwc);
                $out.write_short (first);
                $out.write_octet (cnt);
                $in = _invoke ($out);
                StInt $result[] = StIntSeqHelper.read ($in);
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:transducers/EwcNonExist:1.0"))
                    throw EwcNonExistHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return getNSt (firstEwc, lastEwc, first, cnt        );
            } finally {
                _releaseReply ($in);
            }
  } // getNSt


  /**
      * Get all the {@link EwcData} of the given Ewc at once.
      * @return EwcData from given Ewc
      */
  public EwcData gEwcData (short ewc) throws EwcNonExist
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("gEwcData", true);
                $out.write_short (ewc);
                $in = _invoke ($out);
                EwcData $result = EwcDataHelper.read ($in);
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:transducers/EwcNonExist:1.0"))
                    throw EwcNonExistHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return gEwcData (ewc        );
            } finally {
                _releaseReply ($in);
            }
  } // gEwcData


  /**
      * Get all the {@link EwcData} of the given Ewcs at once.
      *
      * @param firstEwc the first Ewc address to read from
      * @param lastEwc the last Ewc address to read from
      * @return array of EwcData objects from EWCs first..last
      */
  public EwcData[] getEwcData (short firstEwc, short lastEwc) throws EwcNonExist
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getEwcData", true);
                $out.write_short (firstEwc);
                $out.write_short (lastEwc);
                $in = _invoke ($out);
                EwcData $result[] = EwcDataSeqHelper.read ($in);
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:transducers/EwcNonExist:1.0"))
                    throw EwcNonExistHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return getEwcData (firstEwc, lastEwc        );
            } finally {
                _releaseReply ($in);
            }
  } // getEwcData


  /**
      * This is a very powerful method to read multiple Ewc values of interest at once.
      * <p> Returns multiple (not only) ID values (TYPE, HWH, HW, SW, SENESCENCE, STATUS, HALL).
      * @param firstEwc the first Ewc address to read from
      * @param lastEwc the last Ewc address to read from
      * @param idSet bit field indicating values to read
      *	These bits are defined here (from the lowest one): TYPE, HWH, HW, SW, SENESCENCE, STATUS, HALL
      *	If more then one bit is selected the returning values are ordered this way too.
      * @return an array of the requested values (ID or others)
      *	from EWCs firstEwc..lastEwc
      */
  public int[] getId (short firstEwc, short lastEwc, int idSet) throws EwcNonExist
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getId", true);
                $out.write_short (firstEwc);
                $out.write_short (lastEwc);
                $out.write_long (idSet);
                $in = _invoke ($out);
                int $result[] = IntSeqHelper.read ($in);
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:transducers/EwcNonExist:1.0"))
                    throw EwcNonExistHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return getId (firstEwc, lastEwc, idSet        );
            } finally {
                _releaseReply ($in);
            }
  } // getId


  /**
      * This is a very powerful method to read multiple Ewc values of interest at once.
      * <p> Returns multiple (not only) ID values (TYPE, HWH, HW, SW, SENESCENCE, STATUS, HALL).
      * @param selected bit field indicating which Ewcs are to be read from
      *	from bit0 standing for Ewc address 1 to bit 63 standing for Ewc address 64
      * @param idSet bit field indicating values to read
      *	These bits are defined here (from the lowest one): TYPE, HWH, HW, SW, SENESCENCE, STATUS, HALL
      *	If more then one bit is selected the returning values are ordered this way too.
      * @return an array of the requested values (ID or others)
      *	from EWCs selected by bit field
      */
  public int[] gtId (long selected, int idSet)
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("gtId", true);
                $out.write_longlong (selected);
                $out.write_long (idSet);
                $in = _invoke ($out);
                int $result[] = IntSeqHelper.read ($in);
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return gtId (selected, idSet        );
            } finally {
                _releaseReply ($in);
            }
  } // gtId


  /** returns some version info for the EWC ewc. */
  public String getString (short ewc) throws EwcNonExist
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getString", true);
                $out.write_short (ewc);
                $in = _invoke ($out);
                String $result = $in.read_string ();
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:transducers/EwcNonExist:1.0"))
                    throw EwcNonExistHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return getString (ewc        );
            } finally {
                _releaseReply ($in);
            }
  } // getString


  /**
      * This is a very powerful method to set multiple Ewc outputs (analog or switching) at once.
      * <p>Every Ewc address, output type, index of the output and its new value
      * are coded in a single integer using a bit field union.
      * <p>Here is a coding scheme:
      * <p>MSB=0: switching output, ewc address in bits 30..21, output index in bits 20..8, value in bits 7..0
      * <p>MSB=1: analog output, ewc address in bits 30..21, output index in bits 20..16, value in bits 15..0
      * @param packed array of bit fields indicating which outputs and how to set
      * @throws EwcNonExist
      */
  public void setOuts (int[] packed) throws EwcNonExist
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("setOuts", true);
                IntSeqHelper.write ($out, packed);
                $in = _invoke ($out);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:transducers/EwcNonExist:1.0"))
                    throw EwcNonExistHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                setOuts (packed        );
            } finally {
                _releaseReply ($in);
            }
  } // setOuts


  /**
      * Read an EWC i/o function names.
      * If more then one role exists, the strings are separated by u\0000 character.
      * String may begin with parenthesis (), where a mark or expected value may be between.
      * This mark shouldn't be localised.
      * String may have a string parameter separated by u\00a0 (non breaking space) character.
      * This parameter specifies which one key or temperature this port dealing about.
      * @param ewc logical name (address) of the EWC to get its i/o meaning
      * @return a two dimensional string array with an i/o names (roles)
      * The length of every array will be at maximum:
  		ewc.getPosInLength(),
  		(short) ewc.getSwitchOutLength(),
  		(short) ewc.getAnalogOutLength(),
  		(short) ewc.getAnalogInLength(),
  		(short) ewc.getTimerInLength(),
  		(short) ewc.getLongInLength());
      */
  public String[][] roles (short ewc) throws EwcNonExist
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("roles", true);
                $out.write_short (ewc);
                $in = _invoke ($out);
                String $result[][] = String2SeqHelper.read ($in);
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:transducers/EwcNonExist:1.0"))
                    throw EwcNonExistHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return roles (ewc        );
            } finally {
                _releaseReply ($in);
            }
  } // roles


  /**
      * This method reads a communication status (flags) of EWCs given.
      * Instead of signatures the flags are returned.
      * Flags to {@link EwcStateSign} signatures conversion is as follows:
      * 01111000 => UNUSED
      * xxxxxxx0 => OFFLINE
      * xxxxxx01 => NO_SW
      * xxxxx011 => NO_HW
      * xxxx0111 => ONLINE
      * xx0x1111 => DROPOUT
      * x01x1111 => WORKING
      * x11x1111 => CORRECT
      * 
      * 8 bit values are transferred only for every EWC
      * @param firstEwc the first Ewc address to read from
      * @param lastEwc the last Ewc address to read from
      * @return an octet array with a communication state number for EWCs first..last
      */
  public byte[] getS (short firstEwc, short lastEwc) throws EwcNonExist
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("getS", true);
                $out.write_short (firstEwc);
                $out.write_short (lastEwc);
                $in = _invoke ($out);
                byte $result[] = ByteSeqHelper.read ($in);
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:transducers/EwcNonExist:1.0"))
                    throw EwcNonExistHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return getS (firstEwc, lastEwc        );
            } finally {
                _releaseReply ($in);
            }
  } // getS


  /**
      * This method reads a communication status of EWCs given.
      * @see getS();
      * @param selected bit field indicating which Ewcs are to be read from
      *	from bit0 standing for Ewc address 1 to bit 63 standing for Ewc address 64
      * @return an octet array with a communication state number
      *	for EWCs selected by bit field
      */
  public byte[] gtS (long selected)
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("gtS", true);
                $out.write_longlong (selected);
                $in = _invoke ($out);
                byte $result[] = ByteSeqHelper.read ($in);
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return gtS (selected        );
            } finally {
                _releaseReply ($in);
            }
  } // gtS


  /**
      * This method reinitialises the EWC list to given one and restarts the server engine.
      * Use -1 for vacancy position. Addresses 1..64 may be used in this implementation only.
      * @param net Network id if there is more then one connected to the server.
      * @param hwIds array of Ewc hardware ids to set. The first item is for logical name
      * address 1, since 0 is virtual EWC (server).
      * @throws EwcNonExist
      */
  public void setHwIds (byte net, int[] hwIds) throws EwcNonExist
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("setHwIds", true);
                $out.write_octet (net);
                IntSeqHelper.write ($out, hwIds);
                $in = _invoke ($out);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:transducers/EwcNonExist:1.0"))
                    throw EwcNonExistHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                setHwIds (net, hwIds        );
            } finally {
                _releaseReply ($in);
            }
  } // setHwIds


  /**
      * This method modifies the EWC list so the EWC types (MSB of the hwId, IdMSB from now on)
      * are set to values given. Some IdMSB s are defined in @link{EwcResult}.
      * The rest of the hwId will stay unchanged. If no EWC should be on given position,
      * type 255 (FAKE) is used. Addresses 1..64 may be used only in this implementation.
      * @param net Network id if there is more then one connected to the server.
      * @param types array of Ewc IdMSB s to set. The first item is for logical name
      * address 1, since 0 is virtual EWC (server).
      * @throws EwcNonExist
      */
  public void setTypes (byte net, byte[] types) throws EwcNonExist
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("setTypes", true);
                $out.write_octet (net);
                ByteSeqHelper.write ($out, types);
                $in = _invoke ($out);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:transducers/EwcNonExist:1.0"))
                    throw EwcNonExistHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                setTypes (net, types        );
            } finally {
                _releaseReply ($in);
            }
  } // setTypes


  /**
      * This method registers the clients Notice object. Its hall method is called every
      * time when some binary input is changed. Pooling may be avoided this way.
      * @param ewc logical name (address) of the EWC to register for input changes notices.
      * @param object Notice object called if change occured.
      * @throws EwcNonExist
      */
  public void registerNotice (short ewc, Notice ntc) throws EwcNonExist
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("registerNotice", true);
                $out.write_short (ewc);
                NoticeHelper.write ($out, ntc);
                $in = _invoke ($out);
                return;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                if (_id.equals ("IDL:transducers/EwcNonExist:1.0"))
                    throw EwcNonExistHelper.read ($in);
                else
                    throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                registerNotice (ewc, ntc        );
            } finally {
                _releaseReply ($in);
            }
  } // registerNotice

  // Type-specific CORBA::Object operations
  private static String[] __ids = {
    "IDL:transducers/EwcAccess:1.0"};

  public String[] _ids ()
  {
    return (String[])__ids.clone ();
  }

  private void readObject (java.io.ObjectInputStream s) throws java.io.IOException
  {
     String str = s.readUTF ();
     String[] args = null;
     java.util.Properties props = null;
     org.omg.CORBA.ORB orb = org.omg.CORBA.ORB.init (args, props);
   try {
     org.omg.CORBA.Object obj = orb.string_to_object (str);
     org.omg.CORBA.portable.Delegate delegate = ((org.omg.CORBA.portable.ObjectImpl) obj)._get_delegate ();
     _set_delegate (delegate);
   } finally {
     orb.destroy() ;
   }
  }

  private void writeObject (java.io.ObjectOutputStream s) throws java.io.IOException
  {
     String[] args = null;
     java.util.Properties props = null;
     org.omg.CORBA.ORB orb = org.omg.CORBA.ORB.init (args, props);
   try {
     String str = orb.object_to_string (this);
     s.writeUTF (str);
   } finally {
     orb.destroy() ;
   }
  }
} // class _EwcAccessStub
