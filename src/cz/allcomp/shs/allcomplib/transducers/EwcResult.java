/**
 * Copyright (c) 2015, Václav Vilímek
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 	- Redistributions of source code must retain the above copyright notice, this list 
 * 	  of conditions and the following disclaimer.
 *  - Redistributions in binary form must reproduce the above copyright , this list 
 *    of conditions and the following disclaimer in the documentation and/or other materials 
 *    provided with the distribution.
 *  - Neither the name of the ALLCOMP a.s. nor the of its contributors may be used to endorse 
 *    or promote products from this software without specific prior written permission.
 *    
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL VÁCLAV VILÍMEK BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package cz.allcomp.shs.allcomplib.transducers;


/**
* transducers/EwcResult.java .
* Generated by the IDL-to-Java compiler (portable), version "3.2"
* from /home/petr/secret/ewa/AllNet.idl
* Sunday, 15 February 2015 11:26:13 o'clock CET
*/


/** 
  * The <code>EwcResult</code> interface to getting all the Ewc data.
  * <p> No setter method are found here, since it has no sense to set anything on 
  * a hardcopy of the Ewc data.
  */
public interface EwcResult extends org.omg.CORBA.portable.ValueBase
{

  /**
      * Bitmask for the EWC status value to get Ewc address validity flag.
      * Before any data can be transferred to/from EWC, it must have an address.
      * <p>All the communication flags are clear at begin. communicator tries to find
      * an EWCs and give them an address. This process is called baptising.
      * If baptising is successful, both flag ADDR_VALID and HW_VALID are set
      * since baptising in fact finds hardware ID and set address to it.
      * In next steps, SW version and HALL data are read.
      * <p>If EWC stops responding (disconnected, communication errors),
      * flags ADDR_VALID, HALL_VALID and OUTS_VALID are cleared.
      * Then two scenarios are possible.
      * <p>1st: EWC forgot its address.
      * Communicator tries to baptise EWC again. If success, ADDR_VALID is set,
      * while SW_VALID is cleared since HALL_VALID is cleared already. 
      * In next steps, SW version and HALL data are read.
      * <p>2nd: EWC remember its address.
      * Communicator tries read HALL data again. When success, ADDR_VALID and HALL_VALID are both set.
      * Next communication with EWC continues normally.
      * <p>Since communicator can't know which scenarios is pending, it must try both method until
      * one becomes successful.
      * <p>If there is need to change an address of some EWC (assignment HW ID <=> address is changed),
      * communicator resets all the EWC address and clears their ADDR_VALID flags. No other flags are
      * cleared since nothing bad happens to EWC. Then all the EWC are baptised again using new
      * assignments. If success, ADDR_VALID is set, while SW_VALID isn't changed since HALL_VALID is set.
      * So EWCs operations can continue at the new address without breaking.
      */
  public static final int ADDR_VALID = (int)(1);

  /**
      * Bitmask for the EWC status value to get Ewc software version validity flag.
      * For communicator this means serial port is communicating (network interface connected).
      * This flag reset but HALL_VALID set means a fake EWC (spare address).
      */
  public static final int SW_VALID = (int)(2);

  /** 
      * Bitmask for the EWC status value to get Ewc hardware ID validity flag.
      * For communicator this means network serial port is open.
      */
  public static final int HW_VALID = (int)(4);

  /**
      * Bitmask for the EWC status value to get HALL value validity flag (most binary inputs)
      * This also means EWC is active (and present) on the network (online).
      */
  public static final int HALL_VALID = (int)(8);

  /**
      * Bitmask for the EWC status value to get all the outputs validity flag.
      * This flags cleared means outputs has been reset due to communication drop out.
      */
  public static final int OUTS_VALID = (int)(16);

  /** bitmask for the EWC status value to get all the communication bus health flag (no error reported) */
  public static final int BUS_OK = (int)(32);

  /** 
      * Bitmask for the EWC status value to get all the data validity flag.
      * This flag is set after all the data are read from EWC by communicator
      * and reset when data retrieved by application.
      * This way an application knows the communicator has fresh data.
      */
  public static final int DATA_VALID = (int)(64);

  /** bitmask for a flag indicating an EWC with a synchronised output (uEWC and quadruplex) typically */
  public static final int SYNC_OUT = (int)(128);

  /** flags combination indicating no EWC at address given (this never occur otherwise) */
  public static final int FAKE_EWC = (int)((int)((int)((int)(EwcResult.HALL_VALID | EwcResult.DATA_VALID) | EwcResult.OUTS_VALID) | EwcResult.BUS_OK));

  /** quadruplex IdMSB (EWC 0)	*/
  public static final byte QUAD = (byte)(0);

  /** uEWC IdMSB (EWC 1..38)	*/
  public static final byte UEWC = (byte)(1);

  /** UPS IdMSB (EWC 64)	*/
  public static final byte UPS = (byte)(3);

  /** RFID reader IdMSB (EWC 60, front door)	*/
  public static final byte FORE = (byte)(4);

  /** Switchboard IdMSB (EWC 61, 63)	*/
  public static final byte SWBRD = (byte)(5);

  /** Valves IdMSB (EWC 62)	*/
  public static final byte VALV = (byte)(6);

  /** thermoEWC IdMSB (Pt1000 converters for Raketor)	*/
  public static final byte THR = (byte)(7);

  /** e-vicko IdMSB (RFID reader)	*/
  public static final byte EWICKO = (byte)(8);

  /** DIN1010 IdMSB (switchboard DIN module)	*/
  public static final byte DIN = (byte)(0xC);

  /** heating pump monitoring IdMSB	*/
  public static final byte TCC = (byte)(0xD);

  /** ECC IdMSB (coke postmix dosing machine)	*/
  public static final byte ECC = (byte)(0x10);

  /** EPP IdMSB (pepsi postmix dosing machine)	*/
  public static final byte EPP = (byte)(0x11);

  /** AFRICA IdMSB (postmix dosing machine)	*/
  public static final byte AFR = (byte)(0x12);

  /** UDM IdMSB (universal dosing machine)	*/
  public static final byte UDM = (byte)(0x13);

  /** KNOB IdMSB (N-coder fan coil thermostat)	*/
  public static final byte KNOB = (byte)(0x20);

  /** KNOBDIS IdMSB (N-coder fan coil thermostat with display)	*/
  public static final byte KNOBDIS = (byte)(0x21);

  /** SUPPLY IdMSB (switching power supply control unit for PRINTED)	*/
  public static final byte SUPPLY = (byte)(0x22);

  /** TIMER IdMSB (minute clock for PRINTED)	*/
  public static final byte TIMER = (byte)(0x23);

  /** EWC6 IdMSB (old fashion EWC with no programmable address)	*/
  public static final byte EWC6 = (byte)(0xFF);

  /** FAKE IdMSB (fake EWC used for free addresses)	*/
  public static final byte FAKE = (byte)(255);

  /**
      * An EWC class signature getter.
      * <p> This signature identifies which class instance holds data of the given Ewc.
      * It is mainly determined by MSB of the hardware identification number.
      * <p> No ones are defined in this idl file since it's number may be growing.
      * But numbers may be converted to strings using method described
      * in {@link Signature} interface.
      * @return an EWC class signature
      */
  public abstract int getEwcTypeSign ();


  /**
      * Communication state signature may have one of the values defined in {@link EwcStateSign} only.
      * Flags to {@link EwcStateSign} signatures conversion is as follows:
      * 01111000 => UNUSED
      * xxxxxxx0 => OFFLINE
      * xxxxxx01 => NO_SW
      * xxxxx011 => NO_HW
      * xxxx0111 => ONLINE
      * xx0x1111 => DROPOUT
      * x01x1111 => WORKING
      * x11x1111 => CORRECT
      * @return a communication state signature
      */
  public abstract int getCommState ();


  /**
      * Communication status flags bitmap.
      * ADDR_VALID, SW_VALID, HW_VALID, HALL_VALID, DATA_VALID, OUTS_VALID, BUS_OK and SYNC_OUT are 
      * positions defined. Rest are implementation dependant flags.
      * @return a communication status flags
      */
  public abstract int getStatus ();


  /**
      * Ewc's hardware identification number getter.
      * <p> The MSB identifies function of this Ewc.
      * <p> The second significant byte identifies hardware issue of this Ewc.
      * <p> The two lower bytes holds a serial number.
      * <p> The best print format for this number is hexadecimal.
      * @return a hardware identification number
      */
  public abstract int getHwVersion ();


  /**
      * Ewc's software version number getter.
      * <p> The MSB is the binary coded main version number.
      * <p> The lower three bytes holds fraction version number.
      * Every byte holds one ASCII (or Latin 1) fractional character.
      * It is typically a digit (0x30..0x39) but it may be a letter too.
      * If all the byte remains are zero, there are no more characters.
      * @return a software version number
      */
  public abstract int getSwVersion ();


  /**
      * Info about how old are this data.
      * <p> If there is no new data from the Ewc for some time
      * (for example due to communication errors), the older data remains valid.
      * This value distinguishes between the fresh data with no change
      * and the old data. Of course (if communication error remains)
      * after some time the Ewc becomes offline.
      * @return a time in millis
      * @see	#getCommState()
      */
  public abstract long getLastTime ();


  /**
      * Bitfield with up to 32 first digital inputs.
      * <p>If the Ewc has less then 32 digital inputs,
      * the bits not used for digital inputs may hold another information,
      * for example the first analog input. But this is implementation dependant.
      * @return record 1 from the file 0x10 TTPA
      */
  public abstract int getHallValue ();


  /**
      * Digital input getter.
      * <p> It uses a positiv logic,
      * i.e. active state of external signal gets <code>true</code>.
      * <p> It is up to the user to use index in range.
      * Otherwise a nonsence value is returned.
      * @param i the input index from the interval 0..posInLenght-1
      * @return <code>true</code> if digital input is active
      */
  public abstract boolean getPosIn (int i);


  /**
      * @return number of digital inputs of this Ewc
      */
  public abstract short getPosInLength ();


  /**
      * Read backs output state as is read from the Ewc.
      * @param i the output index
      * @return <code>true</code> if output is active (isn't switched off)
      */
  public abstract boolean getBack (int i);


  /**
      * Read back an analog output value as it was set last time.
      * @param i the analog (PWM) output index
      * @return the value last set
      */
  public abstract short getAnalogOut (int i);


  /**
      * @return analogOut.length (number of analog (PWM) outputs)
      */
  public abstract int getAnalogOutLength ();


  /**
      * Read back an switching output value as it was set last time.
      * @param i the switching output index
      * @return the value last set
      */
  public abstract byte getSwitchOut (int i);


  /**
      * @return switchOut.length (number of switching outputs)
      */
  public abstract int getSwitchOutLength ();


  /**
      * Read an analog input value.
      * <p> Typically a result from A/D converter, normalised so
      * the most significant bit of A/D result is also MSB of this value.
      * <p> The drink machines (ECC and so) use this to transfer 16-bit dose counters.
      * <p> Some device (COMM itself) transfers temperatures
      * in centigrades as signed value here.
      * @param i the analog input index
      * @return analogIn value (voltage or counter)
      */
  public abstract short getAnalogIn (int i);


  /**
      * @return analogIn.length (number of voltages or counters)
      */
  public abstract int getAnalogInLength ();


  /**
      * Read a timer or other integer input value.
      * <p> Originally used for SMT160 temperature sensors data, measured by timers.
      * Temperature data are transferred in cents of Kelvin (thus it is an unsigned value).
      * <p> Later also the 32 bit counters became transferred here.
      * @param i the timerIn input index
      * @return timerIn value (temperature or counter)
      */
  public abstract int getTimerIn (int i);


  /**
      * @return timerIn.length (number of temperatures or counters)
      */
  public abstract int getTimerInLength ();


  /**
      * Read a 64-bits long value.
      * <p> A RFID reader uses this only at time of writing.
      * @param i the longIn input index
      * @return longIn 64bit value (RFID)
      */
  public abstract long getLongIn (int i);


  /**
      * @return longIn.length (number of RFID items)
      */
  public abstract int getLongInLength ();

} // interface EwcResult
