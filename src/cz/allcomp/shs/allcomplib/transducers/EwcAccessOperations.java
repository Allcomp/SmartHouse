/**
 * Copyright (c) 2015, Václav Vilímek
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 	- Redistributions of source code must retain the above copyright notice, this list 
 * 	  of conditions and the following disclaimer.
 *  - Redistributions in binary form must reproduce the above copyright , this list 
 *    of conditions and the following disclaimer in the documentation and/or other materials 
 *    provided with the distribution.
 *  - Neither the name of the ALLCOMP a.s. nor the of its contributors may be used to endorse 
 *    or promote products from this software without specific prior written permission.
 *    
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL VÁCLAV VILÍMEK BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package cz.allcomp.shs.allcomplib.transducers;

import cz.allcomp.shs.allcomplib.notice.Notice;


/**
* transducers/EwcAccessOperations.java .
* Generated by the IDL-to-Java compiler (portable), version "3.2"
* from /home/petr/secret/ewa/AllNet.idl
* Sunday, 15 February 2015 11:26:13 o'clock CET
*/


/** 
  * The <code>EwcAccess</code> is the only interface to read (and write) data from the Ewc server.
  * <p> The Ewc address is specified by short (two bytes) value, while Ewc address is 255 maximum.
  * The higher byte is reserved to specify the Ewc net when more then one is present on single server.
  */
public interface EwcAccessOperations 
{

  /**
      * An EWC class signature getter.
      * <p> This signature identifies which class instance holds data of the given Ewc.
      * It is mainly determined by MSB of the hardware identification number.
      * <p> No ones are defined in this idl file since it's number may be growing.
      * But numbers may be converted to strings using method described
      * in {@link Signature} interface.
      * <p> For reading more info and/or more Ewc at once, see
      * {@link #getId(short firstEwc, short lastEwc, int idSet)} and
      * {@link #gtId(long selected, int idSet)} methods.
      * @param ewc the address of the Ewc of interest
      * @return an EWC class signature for a given EWC
      */
  int gType (short ewc) throws EwcNonExist;

  /**
      * Communication status flags.
      * ADDR_VALID, SW_VALID, HW_VALID, HALL_VALID, DATA_VALID, OUTS_VALID, BUS_OK and SYNC_OUT are 
      * positions defined. Rest are implementation dependant flags.
      * <p> For reading more info and/or more Ewc at once, see
      * {@link #getId(short firstEwc, short lastEwc, int idSet)} and
      * {@link #gtId(long selected, int idSet)} methods.
      * @see getS();
      * @param ewc the address of the Ewc of interest
      * @return a communication state signature for a given EWC
      */
  int gS (short ewc) throws EwcNonExist;

  /**
      * Ewc's hardware identification number getter.
      * <p> The MSB identifies function of this Ewc.
      * <p> The second significant byte identifies hardware issue of this Ewc.
      * <p> The two lower bytes holds a serial number.
      * <p> The best print format for this number is hexadecimal.
      * <p> For reading more info and/or more Ewc at once, see
      * {@link #getId(short firstEwc, short lastEwc, int idSet)} and
      * {@link #gtId(long selected, int idSet)} methods.
      * @param ewc the address of the Ewc of interest
      * @return a hardware identification number for a given EWC
      */
  int gHw (short ewc) throws EwcNonExist;

  /**
      * Ewc's software version number getter.
      * <p> The MSB is the binary coded main version number.
      * <p> The lower three bytes holds fraction version number.
      * Every byte holds one ASCII (or Latin 1) fractional character.
      * It is typically a digit (0x30..0x39) but it may be a letter too.
      * If all the byte remains are zero, there are no more characters.
      * <p> For reading more info and/or more Ewc at once, see
      * {@link #getId(short firstEwc, short lastEwc, int idSet)} and
      * {@link #gtId(long selected, int idSet)} methods.
      * @param ewc the address of the Ewc of interest
      * @return a software version number for a given EWC
      */
  int gSw (short ewc) throws EwcNonExist;

  /**
      * Info about how old are this data.
      * <p> If there is no new data from the Ewc for some time
      * (for example due to communication errors), the older data remains valid.
      * This value distinguishes between the fresh data with no change
      * and the old data. Of course (if communication error remains)
      * after some time the Ewc becomes offline.
      * <p> For reading more info and/or more Ewc at once, see
      * {@link #getId(short firstEwc, short lastEwc, int idSet)} and
      * {@link #gtId(long selected, int idSet)} methods.
      * @param ewc the address of the Ewc of interest
      * @return a time in millis from the last message was received by a given EWC
      * @see	#gState(short ewc)
      */
  int gTime (short ewc) throws EwcNonExist;

  /**
      * Bit field with up to 32 first digital inputs.
      * <p>If the Ewc has less then 32 digital inputs,
      * the bits not used for digital inputs may hold another information,
      * for example the first analog input. But this is implementation dependant.
      * <p> For reading more info and/or more Ewc at once, see
      * {@link #getId(short firstEwc, short lastEwc, int idSet)} and
      * {@link #gtId(long selected, int idSet)} methods.
      * @param ewc the address of the Ewc of interest
      * @return record 1 from the file 0x10 TTPA of given EWC
      */
  int gHall (short ewc) throws EwcNonExist;

  /**
      * @param firstEwc the first Ewc address to read from
      * @param lastEwc the last Ewc address to read from
      * @return number of digital inputs for EWCs first..last
      */
  short[] getInLen (short firstEwc, short lastEwc) throws EwcNonExist;

  /**
      * @param selected bit field indicating which Ewcs are to be read
      *	from bit 0 standing for Ewc address 1 to bit 63 standing for Ewc address 64
      * @return number of digital inputs for EWCs selected by bit field
      */
  short[] gtInLen (long selected);

  /**
      * Digital input getter.
      * <p> It uses a positive logic,
      * i.e. active state of external signal gets <code>true</code>.
      * <p> It is up to the user to use index in range.
      * Otherwise a nonsense value is returned.
      * @param ewc the address of the Ewc of interest
      * @param i the input index from the interval 0..posInLenght-1
      * @return <code>true</code> if digital input is active
      */
  boolean getIn (short ewc, short i) throws EwcNonExist;

  /**
      * Read backs output state as is read from the Ewc.
      * @param ewc the address of the Ewc of interest
      * @param i the output index
      * @return <code>true</code> if output is active (isn't switched off)
      */
  boolean getBack (short ewc, short i) throws EwcNonExist;

  /**
      * @param firstEwc the first Ewc address to read from
      * @param lastEwc the last Ewc address to read from
      * @return an array of analogOut.length (number of analog (PWM) outputs)
      *	for EWCs first..last
      */
  short[] getAOutLen (short firstEwc, short lastEwc) throws EwcNonExist;

  /**
      * @param selected bit field indicating which Ewcs are to be read from
      *	from bit 0 standing for Ewc address 1 to bit 63 standing for Ewc address 64
      * @return an array of analogOut.length (number of analog (PWM) outputs)
      *	for EWCs selected by bit field
      */
  short[] gtAOutLen (long selected);

  /**
      * Sets single analogOut (analog (PWM) output).
      * <p> Possible value range is implementation dependant,
      * typically it is value from an interval 0..100 or 0..1000
      * @param ewc the address of the Ewc of interest
      * @param index the output index
      * @param value the new value for this output
      */
  void sAOut (short ewc, short index, short value) throws EwcNonExist;

  /**
      * Sets multiple analogOut (analog (PWM) outputs) in a row.
      * <p> Outputs are set from the <code>first</code> up to the
      * <code>first + values.length - 1</code>
      * <p> Possible value range is implementation dependant,
      * typically it is value from an interval 0..100 or 0..1000
      * @param ewc the address of the Ewc of interest
      * @param first the index to the first output set
      * @param values the new values for these outputs
      */
  void setAOut (short ewc, short first, short[] values) throws EwcNonExist;

  /**
      * Sets multiple analogOut (analog (PWM) outputs) selected by bit field.
      * <p> Possible value range is implementation dependant,
      * typically it is value from an interval 0..100 or 0..1000
      * @param ewc the address of the Ewc of interest
      * @param selected bit field indicating which outputs to be set
      *	from bit0 standing for index 0 to bit 63 standing for index 63
      * @param values the new values for the outputs selected
      */
  void stAOut (short ewc, int selected, short[] values) throws EwcNonExist;

  /**
      * Read back a single analog output value as it was set last time.
      * @param ewc the address of the Ewc of interest
      * @param index the analog (PWM) output index
      * @return the value last set
      */
  short gAOut (short ewc, short index) throws EwcNonExist;

  /**
      * Read back a multiple analog output values as they were set last time.
      * @param ewc the address of the Ewc of interest
      * @param first the index to the first output value to read
      * @param cnt number of outputs to read
      * @return an array of values last set
      */
  short[] getAOut (short ewc, short first, byte cnt) throws EwcNonExist;

  /**
      * @param firstEwc the first Ewc address to read from
      * @param lastEwc the last Ewc address to read from
      * @return an array of switchOut.length (number of switching outputs)
      *	for EWCs first..last
      */
  short[] getOutLen (short firstEwc, short lastEwc) throws EwcNonExist;

  /**
      * @param selected bit field indicating which Ewcs are to be read from
      *	from bit 0 standing for Ewc address 1 to bit 63 standing for Ewc address 64
      * @return an array of switchOut.length (number of switching outputs)
      *	for EWCs selected by bit field
      */
  short[] gtOutLen (long selected);

  /**
      * Sets single switchOut (switching output).
      * <p> Possible value range is implementation dependant,
      * typically it is 0 for switch off and 1 for switch on.
      * A selector switches are using more values.
      * @param ewc the address of the Ewc of interest
      * @param index the output index
      * @param value the new value for this output
      */
  void sOut (short ewc, short index, byte value) throws EwcNonExist;

  /**
      * sets switchOut (switching outputs) from first
      * Sets multiple switchOut (switching outputs) in a row.
      * <p> Outputs are set from the <code>first</code> up to the
      * <code>first + values.length - 1</code>
      * <p> Possible value range is implementation dependant,
      * typically it is 0 for switch off and 1 for switch on.
      * A selector switches are using more values.
      * @param ewc the address of the Ewc of interest
      * @param first the index to the first output set
      * @param values the new values for these outputs
      */
  void setOut (short ewc, short first, byte[] values) throws EwcNonExist;

  /**
      * Sets multiple switchOut (switching outputs) selected by bit field.
      * <p> Possible value range is implementation dependant,
      * typically it is 0 for switch off and 1 for switch on.
      * A selector switches are using more values.
      * @param ewc the address of the Ewc of interest
      * @param selected bit field indicating which outputs to be set
      *	from bit0 standing for index 0 to bit 63 standing for index 63
      * @param values the new values for the outputs selected
      */
  void stOut (short ewc, int selected, byte[] values) throws EwcNonExist;

  /**
      * Read back a single switching output value as it was set last time.
      * @param ewc the address of the Ewc of interest
      * @param index the switching output index
      * @return the value last set
      */
  byte gOut (short ewc, short index) throws EwcNonExist;

  /**
      * Read back a multiple switching output values as they were set last time.
      * @param ewc the address of the Ewc of interest
      * @param first the index to the first output value to read
      * @param cnt number of outputs to read
      * @return an array of values last set
      */
  byte[] getOut (short ewc, short first, byte cnt) throws EwcNonExist;

  /**
      * @param firstEwc the first Ewc address to read from
      * @param lastEwc the last Ewc address to read from
      * @return an array of analogIn.length (number of voltages or counters)
      *	for EWCs first..last
      */
  short[] getAInLen (short firstEwc, short lastEwc) throws EwcNonExist;

  /**
      * @param selected bit field indicating which Ewcs are to be read from
      *	from bit0 standing for Ewc address 1 to bit 63 standing for Ewc address 64
      * @return an array of analogIn.length (number of voltages or counters)
      *	for EWCs selected by bit field
      */
  short[] gtAInLen (long selected);

  /**
      * Read an analog input value.
      * <p> Typically a result from A/D converter, normalised so
      * the most significant bit of A/D result is also MSB of this value.
      * <p> The drink machines (ECC and so) use this to transfer 16-bit dose counters.
      * <p> Some device (COMM itself) transfers temperatures
      * in centigrades as signed value here.
      * @param ewc the address of the Ewc of interest
      * @param index the analog input index
      * @return analogIn value (voltage or counter) for a given EWC
      */
  short gAIn (short ewc, short index) throws EwcNonExist;

  /**
      * Read a multiple analog input values.
      * <p> Typically a result from A/D converter, normalised so
      * the most significant bit of A/D result is also MSB of this value.
      * <p> The drink machines (ECC and so) use this to transfer 16-bit dose counters.
      * <p> Some device (COMM itself) transfers temperatures
      * in centigrades as signed value here.
      * @param firstEwc the first Ewc address to read from
      * @param lastEwc the last Ewc address to read from
      * @param first the index to the first input value to read 
      * @param cnt number of inputs to read from every Ewc
      * @return an array of analogIn values (voltages or counters)
      *	for EWCs firstEwc..lastEwc
      */
  short[] getAIn (short firstEwc, short lastEwc, short first, byte cnt) throws EwcNonExist;

  /**
      * Read a multiple analog input values.
      * <p> Typically a result from A/D converter, normalised so
      * the most significant bit of A/D result is also MSB of this value.
      * <p> The drink machines (ECC and so) use this to transfer 16-bit dose counters.
      * <p> Some device (COMM itself) transfers temperatures
      * in centigrades as signed value here.
      * @param selected bit field indicating which Ewcs are to be read from
      *	from bit0 standing for Ewc address 1 to bit 63 standing for Ewc address 64
      * @param first the index to the first input value to read 
      * @param cnt number of inputs to read from every Ewc
      * @return an array of analogIn values (voltages or counters)
      *	for EWCs selected by bit field
      */
  short[] gtAIn (long selected, short first, byte cnt) throws EwcNonExist;

  /**
      * @param firstEwc the first Ewc address to read from
      * @param lastEwc the last Ewc address to read from
      * @return an array of timerIn.length (number of temperatures or counters)
      *	for EWCs first..last
      */
  short[] getTInLen (short firstEwc, short lastEwc) throws EwcNonExist;

  /**
      * @param selected bit field indicating which Ewcs are to be read from
      *	from bit0 standing for Ewc address 1 to bit 63 standing for Ewc address 64
      * @return an array of timerIn.length (number of temperatures or counters)
      *	for EWCs selected by bit field
      */
  short[] gtTInLen (long selected);

  /**
      * Read a timer or other integer input value.
      * <p> Originally used for SMT160 temperature sensors data, measured by timers.
      * Temperature data are transferred in cents of Kelvin (thus it is unsigned value).
      * <p> Later also the 32 bit counters became transferred here.
      * @param ewc the address of the Ewc of interest
      * @param index the timerIn input index
      * @return timerIn value (temperature or counter) for a given EWC
      */
  int gTIn (short ewc, short index) throws EwcNonExist;

  /**
      * Read a multiple timer or other integer input values.
      * <p> Originally used for SMT160 temperature sensors data, measured by timers.
      * Temperature data are transferred in cents of Kelvin (thus it is unsigned value).
      * <p> Later also the 32 bit counters became transferred here.
      * @param firstEwc the first Ewc address to read from
      * @param lastEwc the last Ewc address to read from
      * @param first the index to the first input value to read 
      * @param cnt number of input values to read from every Ewc
      * @return an array of timerIn values (temperatures or counters)
      *	from EWCs firstEwc..lastEwc
      */
  int[] getTIn (short firstEwc, short lastEwc, short first, byte cnt) throws EwcNonExist;

  /**
      * Read a multiple timer or other integer input values.
      * <p> Originally used for SMT160 temperature sensors data, measured by timers.
      * Temperature data are transferred in cents of Kelvin (thus it is an unsigned value).
      * <p> Later also the 32 bit counters became transferred here.
      * @param selected bit field indicating which Ewcs are to be read from
      *	from bit0 standing for Ewc address 1 to bit 63 standing for Ewc address 64
      * @param first the index to the first input value to read 
      * @param cnt number of input values to read from every Ewc
      * @return an array of timerIn values (temperatures or counters)
      *	from EWCs selected by bit field
      */
  int[] gtTIn (long selected, short first, byte cnt) throws EwcNonExist;

  /**
      * @param firstEwc the first Ewc address to read from
      * @param lastEwc the last Ewc address to read from
      * @return an array of longIn.length (number of RFID items)
      *	for EWCs first..last
      */
  short[] getLInLen (short firstEwc, short lastEwc) throws EwcNonExist;

  /**
      * @param selected bit field indicating which Ewcs are to be read from
      *	from bit0 standing for Ewc address 1 to bit 63 standing for Ewc address 64
      * @return an array of longIn.length (number of RFID items)
      *	for EWCs selected by bit field
      */
  short[] gtLInLen (long selected);

  /**
      * Read a 64-bits long value.
      * <p> A RFID reader uses this only at time of writing.
      * @param ewc the address of the Ewc of interest
      * @param index the longIn input value index
      * @return longIn 64bit value (RFID) for a given EWC
      */
  long gLIn (short ewc, short index) throws EwcNonExist;

  /**
      * Read a multiple 64-bits long values.
      * <p> A RFID reader uses this only at time of writing.
      * @param firstEwc the first Ewc address to read from
      * @param lastEwc the last Ewc address to read from
      * @param first the index to the first input value to read 
      * @param cnt number of input values to read from every Ewc
      * @return an array of longIn 64bit values (RFID)
      *	from EWCs firstEwc..lastEwc
      */
  long[] getLIn (short firstEwc, short lastEwc, short first, byte cnt) throws EwcNonExist;

  /**
      * Read a multiple 64-bits long values.
      * <p> A RFID reader uses this only at time of writing.
      * @param selected bit field indicating which Ewcs are to be read from
      *	from bit0 standing for Ewc address 1 to bit 63 standing for Ewc address 64
      * @param first the index to the first input value to read 
      * @param cnt number of input values to read from every Ewc
      * @return an array of longIn 64bit values (RFID)
      *	from EWCs selected by bit field
      */
  long[] gtLIn (long selected, short first, byte cnt) throws EwcNonExist;

  /**
      * @param firstEwc the first Ewc address to read from
      * @param lastEwc the last Ewc address to read from
      * @return an array of StatisticInt.length (number of integer series statistic objects)
      *	for EWCs first..last
      */
  short[] getStLen (short firstEwc, short lastEwc) throws EwcNonExist;

  /**
      * @param selected bit field indicating which Ewcs are to be read from
      *	from bit0 standing for Ewc address 1 to bit 63 standing for Ewc address 64
      * @return an array of StatisticInt.length (number of integer series statistic objects)
      *	for EWCs selected by bit field
      */
  short[] gtStLen (long selected);

  /**
      * Get a statistical data from the last {@link #gNSt(short ewc, short index)} invocation.
      * <p> A statistic is calculated from the A/D conversion values
      * used for bucket conveyor load sensor on EWCS.
      * @param ewc the address of the Ewc of interest
      * @param index the statisticInt object index
      * @return statistical data from given EWC
      */
  StInt gSt (short ewc, short index) throws EwcNonExist;

  /**
      * Get a statistical data from the last {@link #gNSt(short ewc, short index)} invocation.
      * <p> A statistic is calculated from the A/D conversion values used for
      * bucket conveyor load sensor on EWCS.
      * @param firstEwc the first Ewc address to read from
      * @param lastEwc the last Ewc address to read from
      * @param first the index to the first statistics to read 
      * @param cnt number of statistics to read from every Ewc
      * @return array of statistical data objects from EWCs first..last
      */
  StInt[] getSt (short firstEwc, short lastEwc, short first, byte cnt) throws EwcNonExist;

  /**
      * Get statistical data from the last invocation of this method.
      * <p> A statistic is calculated from the A/D conversion value 0 used for
      * bucket conveyor load sensor on EWCS.
      * <p> To read data not clearing series use {@link #gSt(short ewc, short index)}.
      * @param ewc the address of the Ewc of interest
      * @param index the statisticInt object index
      * @return statistical data from given EWC
      */
  StInt gNSt (short ewc, short index) throws EwcNonExist;

  /**
      * Get statistical data from the last invocation of this method.
      * <p> A statistic is calculated from the A/D conversion value 0 used for
      * bucket conveyor load sensor on EWCS.
      * <p> To read data not clearing series use {@link #getSt(short firstEwc, short lastEwc, short first, byte cnt)}.
      * @param firstEwc the first Ewc address to read from
      * @param lastEwc the last Ewc address to read from
      * @param first the index to the first statistics to read 
      * @param cnt number of statistics to read from every Ewc
      * @return array of statistical data objects from EWCs first..last
      */
  StInt[] getNSt (short firstEwc, short lastEwc, short first, byte cnt) throws EwcNonExist;

  /**
      * Get all the {@link EwcData} of the given Ewc at once.
      * @return EwcData from given Ewc
      */
  EwcData gEwcData (short ewc) throws EwcNonExist;

  /**
      * Get all the {@link EwcData} of the given Ewcs at once.
      *
      * @param firstEwc the first Ewc address to read from
      * @param lastEwc the last Ewc address to read from
      * @return array of EwcData objects from EWCs first..last
      */
  EwcData[] getEwcData (short firstEwc, short lastEwc) throws EwcNonExist;

  /**
      * This is a very powerful method to read multiple Ewc values of interest at once.
      * <p> Returns multiple (not only) ID values (TYPE, HWH, HW, SW, SENESCENCE, STATUS, HALL).
      * @param firstEwc the first Ewc address to read from
      * @param lastEwc the last Ewc address to read from
      * @param idSet bit field indicating values to read
      *	These bits are defined here (from the lowest one): TYPE, HWH, HW, SW, SENESCENCE, STATUS, HALL
      *	If more then one bit is selected the returning values are ordered this way too.
      * @return an array of the requested values (ID or others)
      *	from EWCs firstEwc..lastEwc
      */
  int[] getId (short firstEwc, short lastEwc, int idSet) throws EwcNonExist;

  /**
      * This is a very powerful method to read multiple Ewc values of interest at once.
      * <p> Returns multiple (not only) ID values (TYPE, HWH, HW, SW, SENESCENCE, STATUS, HALL).
      * @param selected bit field indicating which Ewcs are to be read from
      *	from bit0 standing for Ewc address 1 to bit 63 standing for Ewc address 64
      * @param idSet bit field indicating values to read
      *	These bits are defined here (from the lowest one): TYPE, HWH, HW, SW, SENESCENCE, STATUS, HALL
      *	If more then one bit is selected the returning values are ordered this way too.
      * @return an array of the requested values (ID or others)
      *	from EWCs selected by bit field
      */
  int[] gtId (long selected, int idSet);

  /** returns some version info for the EWC ewc. */
  String getString (short ewc) throws EwcNonExist;

  /**
      * This is a very powerful method to set multiple Ewc outputs (analog or switching) at once.
      * <p>Every Ewc address, output type, index of the output and its new value
      * are coded in a single integer using a bit field union.
      * <p>Here is a coding scheme:
      * <p>MSB=0: switching output, ewc address in bits 30..21, output index in bits 20..8, value in bits 7..0
      * <p>MSB=1: analog output, ewc address in bits 30..21, output index in bits 20..16, value in bits 15..0
      * @param packed array of bit fields indicating which outputs and how to set
      * @throws EwcNonExist
      */
  void setOuts (int[] packed) throws EwcNonExist;

  /**
      * Read an EWC i/o function names.
      * If more then one role exists, the strings are separated by u\0000 character.
      * String may begin with parenthesis (), where a mark or expected value may be between.
      * This mark shouldn't be localised.
      * String may have a string parameter separated by u\00a0 (non breaking space) character.
      * This parameter specifies which one key or temperature this port dealing about.
      * @param ewc logical name (address) of the EWC to get its i/o meaning
      * @return a two dimensional string array with an i/o names (roles)
      * The length of every array will be at maximum:
  		ewc.getPosInLength(),
  		(short) ewc.getSwitchOutLength(),
  		(short) ewc.getAnalogOutLength(),
  		(short) ewc.getAnalogInLength(),
  		(short) ewc.getTimerInLength(),
  		(short) ewc.getLongInLength());
      */
  String[][] roles (short ewc) throws EwcNonExist;

  /**
      * This method reads a communication status (flags) of EWCs given.
      * Instead of signatures the flags are returned.
      * Flags to {@link EwcStateSign} signatures conversion is as follows:
      * 01111000 => UNUSED
      * xxxxxxx0 => OFFLINE
      * xxxxxx01 => NO_SW
      * xxxxx011 => NO_HW
      * xxxx0111 => ONLINE
      * xx0x1111 => DROPOUT
      * x01x1111 => WORKING
      * x11x1111 => CORRECT
      * 
      * 8 bit values are transferred only for every EWC
      * @param firstEwc the first Ewc address to read from
      * @param lastEwc the last Ewc address to read from
      * @return an octet array with a communication state number for EWCs first..last
      */
  byte[] getS (short firstEwc, short lastEwc) throws EwcNonExist;

  /**
      * This method reads a communication status of EWCs given.
      * @see getS();
      * @param selected bit field indicating which Ewcs are to be read from
      *	from bit0 standing for Ewc address 1 to bit 63 standing for Ewc address 64
      * @return an octet array with a communication state number
      *	for EWCs selected by bit field
      */
  byte[] gtS (long selected);

  /**
      * This method reinitialises the EWC list to given one and restarts the server engine.
      * Use -1 for vacancy position. Addresses 1..64 may be used in this implementation only.
      * @param net Network id if there is more then one connected to the server.
      * @param hwIds array of Ewc hardware ids to set. The first item is for logical name
      * address 1, since 0 is virtual EWC (server).
      * @throws EwcNonExist
      */
  void setHwIds (byte net, int[] hwIds) throws EwcNonExist;

  /**
      * This method modifies the EWC list so the EWC types (MSB of the hwId, IdMSB from now on)
      * are set to values given. Some IdMSB s are defined in @link{EwcResult}.
      * The rest of the hwId will stay unchanged. If no EWC should be on given position,
      * type 255 (FAKE) is used. Addresses 1..64 may be used only in this implementation.
      * @param net Network id if there is more then one connected to the server.
      * @param types array of Ewc IdMSB s to set. The first item is for logical name
      * address 1, since 0 is virtual EWC (server).
      * @throws EwcNonExist
      */
  void setTypes (byte net, byte[] types) throws EwcNonExist;

  /**
      * This method registers the clients Notice object. Its hall method is called every
      * time when some binary input is changed. Pooling may be avoided this way.
      * @param ewc logical name (address) of the EWC to register for input changes notices.
      * @param object Notice object called if change occured.
      * @throws EwcNonExist
      */
  void registerNotice (short ewc, Notice ntc) throws EwcNonExist;
} // interface EwcAccessOperations
